package CUP;

import java_cup.runtime.Symbol;
/**
*import java_cup.runtime.*;
**/

parser code
{:
    private Symbol s;
    
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    public void syntax_error(Symbol s){
        this.s = s;
        System.out.println("Error Sintáctico recuperable en la Línea " + (s.right) +
        " Columna "+s.left+ ". No se esperaba este componente: " +s.value+".");
    }

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la Línea " + 
        (s.right)+ " Columna "+s.left+". Componente " + s.value + 
        " no reconocido."); 
    }

    public Symbol getS(){
        return this.s;
    }
:};
/* code structure */
terminal 
  ERROR,
  CLOSE_BLOCK,
  OPEN_PARENTESIS,
  CLOSE_PARENTESIS,
  PYC,
  BETWEEN,
  OPEN_SQR_BRACKET,
  CLOSE_SQR_BRACKET,
  COMA,
  COLON,
  BACK_SLASH,
  NEW_LINE,
  NULL,
  TRUE,
  FALSE,
  STRING,
  CHAR_ELEMENT;

/* control statements */
  terminal FUNCTION,
  IF_SWITCH,
  PRINT,
  WHILE,
  FOR,
  ELSE,
  RETURN,
  CIN,
  TO,
  MAIN;

/* operators */
  terminal OP_REL,
  OP_SUM,
  OP_MULTI_DIV,
  MOD,
  INCREMENT,
  CON_AND,
  CON_OR;

/* data types */
  terminal INTENGER,
  BOOLEAN,
  CHAR,
  ARRAY,
  MATRIX,
  VARIABLE;

/* identifier */
  terminal String ID;
  terminal Integer NUMBER;

/* Non terminals */
non terminal N_INICIO, N_WHILE, N_FOR, N_IF, N_TIPO_VARIABLE, N_ARREGLO, N_MATRIZ,
            N_OPERACIONAL, N_SENTENCIA_BOOLEANA, N_SENTENCIA, N_DECLARACION, N_AND_OR,
            N_SWITCH, N_SWITCH_CASE, N_FUNCTION, N_PARAMETRO_FUNCTION, N_RETORNO_FUNCTION,
            N_SENTENCIA_BOOLEANA_ANIDADA, N_PRINT;

/* Onda fumada de Wilfredo */
non terminal EXPR_LIST,
SOUT
;
non terminal Integer    expr;      // used to store evaluated subexpressions

/* Precedences */
precedence left OP_SUM;
precedence left OP_MULTI_DIV;

start with N_INICIO;

/* The grammar rules */
EXPR_LIST   ::= EXPR_LIST expr:e PYC         {: System.out.println(e);:}
            | expr:e PYC                     {: System.out.println(e);:}
;

expr        ::= expr:e1 OP_SUM  expr:e2                 {: RESULT = e1+e2;  :}
            | expr:e1 OP_MULTI_DIV expr:e2              {: RESULT = e1*e2;  :}
            | OPEN_PARENTESIS expr:e CLOSE_PARENTESIS   {: RESULT = e;      :}
            | NUMBER:n	                                {: RESULT = n;      :}
;
/* Fin de la Onda fumada de Wilfredo */



N_INICIO ::= 
    OPEN_PARENTESIS CLOSE_PARENTESIS OPEN_PARENTESIS MAIN COLON N_SENTENCIA
;


N_WHILE ::= 
OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA CLOSE_PARENTESIS OPEN_PARENTESIS WHILE COLON N_SENTENCIA
;

N_FOR ::= 
OPEN_PARENTESIS ID COMA NUMBER TO NUMBER COMA INCREMENT CLOSE_PARENTESIS OPEN_PARENTESIS FOR COLON N_SENTENCIA
;

/*IF    SWTICH*/
N_IF ::= 
OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON N_SENTENCIA |
OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON N_SENTENCIA OPEN_PARENTESIS ELSE CLOSE_PARENTESIS COLON  N_SENTENCIA
;

N_SWITCH ::=
OPEN_PARENTESIS ID CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON N_SWITCH_CASE
;

N_SWITCH_CASE ::=
OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA CLOSE_PARENTESIS COLON N_SENTENCIA N_SWITCH_CASE |
OPEN_PARENTESIS ELSE CLOSE_PARENTESIS COLON N_SENTENCIA
;

N_FUNCTION ::=
OPEN_PARENTESIS N_PARAMETRO_FUNCTION CLOSE_PARENTESIS ID OPEN_PARENTESIS FUNCTION COLON N_RETORNO_FUNCTION N_SENTENCIA
;

N_PARAMETRO_FUNCTION ::=
N_DECLARACION COMA N_PARAMETRO_FUNCTION |
N_DECLARACION
;

N_RETORNO_FUNCTION ::=
    INTENGER |
    BOOLEAN |
    CHAR |
    ARRAY |
    MATRIX |
    /*Vacio significa void o procedimiento*/
;
N_SENTENCIA ::= 
    N_WHILE CLOSE_BLOCK N_SENTENCIA|
    N_FOR CLOSE_BLOCK N_SENTENCIA|
    N_IF CLOSE_BLOCK N_SENTENCIA|
    N_SWITCH CLOSE_BLOCK N_SENTENCIA|
    N_DECLARACION PYC N_SENTENCIA|
    N_PRINT PYC N_SENTENCIA | 
    CLOSE_BLOCK
/*Houston tenemos un problema, 
No se puede poner nada despues de cada uno, solo dentro*/
;

N_DECLARACION ::= 
    VARIABLE ID |
    INTENGER ID |
    BOOLEAN ID  |
    CHAR ID |
    ARRAY ID  |
    MATRIX ID  |

    INTENGER ID COLON NUMBER  |
    BOOLEAN ID COLON FALSE  |
    BOOLEAN ID COLON TRUE  |
    BOOLEAN ID COLON N_SENTENCIA_BOOLEANA_ANIDADA  |
    CHAR ID COLON CHAR_ELEMENT |
    CHAR ID COLON STRING  |
    ARRAY ID COLON OPEN_SQR_BRACKET N_ARREGLO  |
    //ARRAY ID COLON N_MATRIZ  |
    MATRIX ID COLON OPEN_SQR_BRACKET N_MATRIZ CLOSE_SQR_BRACKET 
;


N_ARREGLO ::=
    N_TIPO_VARIABLE COMA N_ARREGLO | N_TIPO_VARIABLE CLOSE_SQR_BRACKET
    /*N_TIPO_VARIABLE COMA N_ARREGLO | */
;  

N_MATRIZ ::= 
    OPEN_SQR_BRACKET N_ARREGLO |
    OPEN_SQR_BRACKET N_ARREGLO COMA N_MATRIZ |
    N_TIPO_VARIABLE COMA N_MATRIZ | N_TIPO_VARIABLE
;

N_TIPO_VARIABLE ::=
NUMBER | ID | STRING | NULL
;

N_SENTENCIA_BOOLEANA_ANIDADA ::=
    N_SENTENCIA_BOOLEANA N_AND_OR
;

N_SENTENCIA_BOOLEANA ::= 
    /*ID*/
    ID OP_REL ID |
    ID OP_REL NUMBER |
    ID OP_REL STRING  |
    ID OP_REL FALSE  |
    ID OP_REL TRUE  |
        /* AL REVES */
    NUMBER OP_REL ID  |
    STRING OP_REL ID  |
    FALSE OP_REL ID  |
    TRUE OP_REL ID  
    
    /*Number*/
    NUMBER OP_REL NUMBER |
    NUMBER OP_REL STRING |
    NUMBER OP_REL FALSE |
    NUMBER OP_REL TRUE |
        /* AL REVES */
    STRING OP_REL NUMBER |
    FALSE OP_REL NUMBER |
    TRUE OP_REL NUMBER  

    /*STRING*/
    STRING OP_REL STRING |
    STRING OP_REL FALSE |
    STRING OP_REL TRUE |
        /* AL REVES */
    FALSE OP_REL STRING |
    TRUE OP_REL STRING  


    /*TRUE - FALSE*/
    TRUE OP_REL FALSE |
    TRUE OP_REL TRUE |
    FALSE OP_REL FALSE |
    FALSE OP_REL TRUE  
;

N_AND_OR::=
    CON_AND N_SENTENCIA_BOOLEANA N_AND_OR|
    CON_OR N_SENTENCIA_BOOLEANA N_AND_OR|

;

N_PRINT ::=
    OPEN_PARENTESIS PRINT COLON STRING CLOSE_BLOCK
;

N_OPERACIONAL ::=
MOD | 
ELSE | 
RETURN |
BACK_SLASH |
ERROR
;
