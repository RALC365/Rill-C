package CUP;

import java_cup.runtime.Symbol;
/**
*import java_cup.runtime.*;
**/

parser code
{:
    private Symbol s;
    
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    public void syntax_error(Symbol s){
        this.s = s;
        System.out.println("Error Sintáctico recuperable en la Línea " + (s.right) +
        " Columna "+s.left+ ". No se esperaba este componente: " +s.value+".");
    }

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la Línea " + 
        (s.right)+ " Columna "+s.left+". Componente " + s.value + 
        " no reconocido."); 
    }

    public Symbol getS(){
        return this.s;
    }
:};
/* code structure */
terminal 
  ERROR,
  CLOSE_BLOCK,
  OPEN_PARENTESIS,
  CLOSE_PARENTESIS,
  PYC,
  BETWEEN,
  OPEN_SQR_BRACKET,
  CLOSE_SQR_BRACKET,
  COMA,
  COLON,
  BACK_SLASH,
  NEW_LINE,
  NULL,
  TRUE,
  FALSE,
  STRING,
  CHAR_ELEMENT;

/* control statements */
  terminal FUNCTION,
  IF_SWITCH,
  PRINT,
  WHILE,
  FOR,
  ELSE,
  RETURN,
  CIN,
  TO,
  MAIN;

/* operators */
  terminal OP_REL,
  OP_SUM,
  OP_MULTI_DIV,
  MOD,
  INCREMENT,
  CON_AND,
  CON_OR;

/* data types */
  terminal INTENGER,
  BOOLEAN,
  CHAR,
  ARRAY,
  MATRIX,
  VARIABLE;

/* identifier */
  terminal String ID;
  terminal Integer NUMBER;

/* Non terminals */
non terminal N_INICIO, N_WHILE, N_FOR, N_IF, N_TIPO_VARIABLE, N_ARREGLO, N_MATRIZ,
            N_OPERACIONAL, N_SENTENCIA_BOOLEANA, N_SENTENCIA, N_DECLARACION, N_AND_OR,
            N_SWITCH, N_SWITCH_CASE, N_FUNCTION, N_PARAMETRO_FUNCTION, N_RETORNO_FUNCTION;

/* Onda fumada de Wilfredo */
non terminal EXPR_LIST,
SOUT
;
non terminal Integer    expr;      // used to store evaluated subexpressions

/* Precedences */
precedence left OP_SUM;
precedence left OP_MULTI_DIV;

start with N_INICIO;

/* The grammar rules */
EXPR_LIST   ::= EXPR_LIST expr:e PYC         {: System.out.println(e);:}
            | expr:e PYC                     {: System.out.println(e);:}
;

expr        ::= expr:e1 OP_SUM  expr:e2                 {: RESULT = e1+e2;  :}
            | expr:e1 OP_MULTI_DIV expr:e2              {: RESULT = e1*e2;  :}
            | OPEN_PARENTESIS expr:e CLOSE_PARENTESIS   {: RESULT = e;      :}
            | NUMBER:n	                                {: RESULT = n;      :}
;
/* Fin de la Onda fumada de Wilfredo */



N_INICIO ::= 
    OPEN_PARENTESIS CLOSE_PARENTESIS OPEN_PARENTESIS MAIN COLON N_SENTENCIA CLOSE_BLOCK
;


N_WHILE ::= 
OPEN_PARENTESIS N_SENTENCIA_BOOLEANA CLOSE_PARENTESIS OPEN_PARENTESIS WHILE COLON N_SENTENCIA CLOSE_BLOCK 
;

N_FOR ::= 
OPEN_PARENTESIS ID COMA NUMBER TO NUMBER COMA INCREMENT CLOSE_PARENTESIS OPEN_PARENTESIS FOR COLON N_SENTENCIA CLOSE_BLOCK
;

/*IF    SWTICH*/
N_IF ::= 
OPEN_PARENTESIS N_SENTENCIA_BOOLEANA CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON N_SENTENCIA CLOSE_BLOCK |
OPEN_PARENTESIS N_SENTENCIA_BOOLEANA CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON N_SENTENCIA OPEN_PARENTESIS ELSE CLOSE_PARENTESIS COLON  N_SENTENCIA CLOSE_BLOCK 
;

N_SWITCH ::=
OPEN_PARENTESIS ID CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON N_SWITCH_CASE CLOSE_BLOCK
;

N_SWITCH_CASE ::=
OPEN_PARENTESIS N_SENTENCIA_BOOLEANA CLOSE_PARENTESIS COLON N_SENTENCIA N_SWITCH_CASE |
OPEN_PARENTESIS ELSE CLOSE_PARENTESIS COLON N_SENTENCIA
;

N_FUNCTION ::=
OPEN_PARENTESIS N_PARAMETRO_FUNCTION CLOSE_PARENTESIS ID OPEN_PARENTESIS FUNCTION COLON N_RETORNO_FUNCTION N_SENTENCIA CLOSE_BLOCK
;

N_PARAMETRO_FUNCTION ::=
N_DECLARACION COMA N_PARAMETRO_FUNCTION |
N_DECLARACION
;

N_RETORNO_FUNCTION ::=
    INTENGER |
    BOOLEAN |
    CHAR |
    ARRAY |
    MATRIX |
    /*Vacio significa void o procedimiento*/
;
N_SENTENCIA ::= 
    N_WHILE |
    N_FOR |
    N_IF |
    N_SWITCH |
    N_DECLARACION
/*Houston tenemos un problema, No se puede poner nada despues de N_DECLARACION*/
;

N_DECLARACION ::= 
    VARIABLE ID PYC |
    INTENGER ID PYC |
    BOOLEAN ID PYC |
    CHAR ID PYC |
    ARRAY ID PYC |
    MATRIX ID PYC |

    INTENGER ID COLON NUMBER PYC |
    BOOLEAN ID COLON FALSE PYC |
    BOOLEAN ID COLON TRUE PYC |
    BOOLEAN ID COLON N_SENTENCIA_BOOLEANA PYC |
    CHAR ID COLON CHAR_ELEMENT PYC|
    CHAR ID COLON STRING PYC |
    ARRAY ID COLON OPEN_SQR_BRACKET N_ARREGLO CLOSE_SQR_BRACKET PYC |
    MATRIX ID COLON OPEN_SQR_BRACKET N_MATRIZ CLOSE_SQR_BRACKET PYC
;

N_PYC_MAS ::=
PYC N_SENTENCIA | 
;

N_ARREGLO ::=
    NUMBER COMA N_ARREGLO | 
    STRING COMA N_ARREGLO |
;

N_MATRIZ ::= 
    OPEN_SQR_BRACKET N_ARREGLO CLOSE_SQR_BRACKET |
    OPEN_SQR_BRACKET N_ARREGLO CLOSE_SQR_BRACKET COMA N_MATRIZ |
    N_ARREGLO | N_ARREGLO COMA N_MATRIZ
;

N_TIPO_VARIABLE ::=
NUMBER | ID | STRING
;


N_SENTENCIA_BOOLEANA ::= 
    ID OP_REL ID N_AND_OR|
    ID OP_REL NUMBER N_AND_OR|
    ID OP_REL STRING N_AND_OR|
    ID OP_REL FALSE N_AND_OR|
    ID OP_REL TRUE N_AND_OR|

    /* AL REVES */
    NUMBER OP_REL ID N_AND_OR|
    STRING OP_REL ID N_AND_OR|
    FALSE OP_REL ID N_AND_OR|
    TRUE OP_REL ID N_AND_OR
;

N_AND_OR::=
    CON_AND N_SENTENCIA_BOOLEANA|
    CON_OR N_SENTENCIA_BOOLEANA|

;

N_OPERACIONAL ::=
MOD | 
ELSE | 
RETURN |
BACK_SLASH |
ERROR
;
