package CUP;

import java_cup.runtime.Symbol;
/**
*import java_cup.runtime.*;
**/
//Arbolito de Compi
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

parser code
{:
    private Symbol s;
    
    public Symbol getS(){
            return this.s;
        }
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    public void syntax_error(Symbol s){
        this.s = s;
        System.out.println("Error Sintáctico recuperable en la Línea " + (s.right + 1) +
        " Columna "+s.left+ ". No se esperaba este componente: " +s.value+".");

        String report = "Syntax error in line " + (getS().right + 1) + " Column " + getS().left + ". No se esperaba este componente: " + getS().value;
        if(getS().value == null){
            report = "You didn't close your last code structure";
        }
        addError(report + "\n");
         
    }

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la Línea " + 
        (s.right)+ " Columna "+s.left+". Componente " + s.value + 
        " no reconocido."); 
    }
    
    //Guardar los errores encontrados
    private String ERRORES = "";
    private int cERRORES = 0;
    public void addError(String error){
        this.ERRORES += error;
       this.cERRORES++;
    }

    public void addMessageErrorOnly(String desc){
        this.ERRORES += desc;
    }
    public String getERRORES(){
        return this.ERRORES;
    }
    public void setERRORES(String err){
        this.ERRORES = err;
    }

    public int getcERRORES(){
        return this.cERRORES;
    }
    public void setcERRORES(int err){
        this.cERRORES = err;
    }

    public String errorMessage(String error, Symbol s){
        //String report = "Syntax error in line " + s.right + " Column " + s.left + ". No se esperaba este componente: " +s.value+ "\nDescripción: " + error +"\n";
        this.addMessageErrorOnly("Comentario: " + error+"\n");
        System.out.println("Cantidad: " + getcERRORES());
        return "Listo, guapo ;D";
    }

    //Se vino el arbolito papa
    DefaultMutableTreeNode sintaxTree;
    DefaultTreeModel sintaxTreeModel;
    DefaultMutableTreeNode nodoActual;

    public DefaultTreeModel createTreeSintax(String name){
        this.sintaxTree = new DefaultMutableTreeNode(name);
        this.sintaxTreeModel = new DefaultTreeModel(sintaxTree);
        this.nodoActual = this.sintaxTree;
        return sintaxTreeModel;
    }
    
    public DefaultMutableTreeNode getTreeSintax(){
        return this.sintaxTree;
    }
    
    public DefaultTreeModel getTreeSintaxModel(){
        return this.sintaxTreeModel;
    }

     public DefaultMutableTreeNode createNodo(String name){
        return new DefaultMutableTreeNode(name);
    }
    
    public void agregarNodo(DefaultMutableTreeNode nodo){
        this.sintaxTree.add(nodo);
    }
    
    public void setNodoActual(DefaultMutableTreeNode nodo){
        this.nodoActual = nodo;
    }

    public DefaultMutableTreeNode getNodoActual(){
        return this.nodoActual;
    }

    public DefaultMutableTreeNode addAllChildren(DefaultMutableTreeNode father, DefaultMutableTreeNode padrastro){
        for (int i = 0; i < father.getChildCount(); i++) {
            padrastro.add((DefaultMutableTreeNode)father.getChildAt(i));
        }
        return padrastro;
    }
:};
/* code structure */
terminal 
  ERROR,
  CLOSE_BLOCK,
  OPEN_PARENTESIS,
  CLOSE_PARENTESIS,
  PYC,
  BETWEEN,
  OPEN_SQR_BRACKET,
  CLOSE_SQR_BRACKET,
  COMA,
  COLON,
  BACK_SLASH,
  NEW_LINE,
  NULL,
  TRUE,
  FALSE,
  STRING,
  CHAR_ELEMENT;

/* control statements */
  terminal FUNCTION,
  IF_SWITCH,
  PRINT,
  WHILE,
  FOR,
  ELSE,
  RETURN,
  CIN,
  TO,
  MAIN;

/* operators */
  terminal OP_REL,
  OP_SUM,
  OP_MULTI_DIV,
  MOD,
  INCREMENT,
  CON_AND,
  CON_OR;

/* data types */
  terminal INTENGER,
  BOOLEAN,
  CHAR,
  ARRAY,
  MATRIX,
  VARIABLE;

/* identifier */
  terminal String ID;
  terminal Integer NUMBER;

/* Non terminals */
non terminal 
    /* code blocks */
    N_INICIO, 
    N_MAIN,
    N_FUNCTIONS,
    N_FUNCTION,
    N_PARAMETRO,
    N_PARAMETRO_FUNCTION, 
    N_RETORNO_FUNCTION,

    /* control statement */
    N_SENTENCIA,
    N_WHILE,
    N_FOR,
        N_TO_FOR,
    N_IF,
        N_ELSE_IF,
    N_SWITCH,
    N_SWITCH_CASE,
    N_SENTENCIA_BOOLEANA_SWITCH,
    N_CALL_FUNCTION,
    N_CALL_FUNCTION_PARAMETROS,

    /*variable definition*/
    N_SENTENCIA_BOOLEANA_ANIDADA,
    N_SENTENCIA_BOOLEANA,   
    N_AND_OR,
    N_DECLARACION,
    N_DECLARACION_ID, //Para las declaraciones int a,b,c,d.,
    N_VALOR_VARIABLE,
    N_MATRIZ,
    N_TIPOS_DECLARACION_MATRIZ,
    N_ARREGLO,
    N_BOOLEAN_ID,
    N_BOOLEAN_VALUE,
    N_ARGUMENTOS,

    /*Opetators*/
    N_PRINT,
    N_PRINT_IMPRESS,
    N_CIN,

    /*MATHEMATICS*/
    EXPR_LIST,
    EXPR
    ;

/*Preferences*/
precedence left CON_AND;
precedence left OP_SUM;
precedence left OP_MULTI_DIV, MOD;
precedence left OPEN_PARENTESIS, CLOSE_PARENTESIS;
                        start with N_INICIO;

/* -------------------------CODE BLOCKS------------------------------------- */
N_INICIO ::= 
    N_MAIN:e1
    |
    N_MAIN:e1 N_FUNCTIONS
    //Se elimno que comenzará con funciones
    /*error:e {: 
        String report = "Syntax error in line " + parser.getS().right + " Column " + parser.getS().left + ". No se esperaba este componente: " +parser.getS().value;
        //parser.addError(report + "\n");
        //parser.report_(report,e); 
        //System.out.println("Error: " + "1\n\n\n\n");
    :}*/
;

N_MAIN ::=
    OPEN_PARENTESIS 
    CLOSE_PARENTESIS 
    OPEN_PARENTESIS 
    MAIN 
    COLON 
    N_SENTENCIA:e
    CLOSE_BLOCK
    |OPEN_PARENTESIS CLOSE_PARENTESIS error:err MAIN COLON N_SENTENCIA:e CLOSE_BLOCK{:
                String desc = "Debe volver a abrir parentesis antes de main \"()(main: -código- :)\" ";
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
                //parser.report_(mes ,err);
        :}
    |
    OPEN_PARENTESIS
    CLOSE_PARENTESIS
    OPEN_PARENTESIS
    MAIN COLON
    CLOSE_BLOCK
    |OPEN_PARENTESIS CLOSE_PARENTESIS OPEN_PARENTESIS error:err COLON N_SENTENCIA:e CLOSE_BLOCK{:
                String desc = "Falta el \"main\" al inicio" ;
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
                //parser.report_(mes ,err);
        :}

    |OPEN_PARENTESIS error CLOSE_PARENTESIS OPEN_PARENTESIS MAIN COLON N_SENTENCIA:e CLOSE_BLOCK{:
                String desc = "El main no debe tener parametros";
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
                //parser.report_(mes ,err);
        :}
    |
    error:err {:
                String desc = "Debe iniciar con el main primero";
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                System.out.println("error: " + err);
                RESULT = nodo;
                //parser.report_error(mes ,err);
        :}
    OPEN_PARENTESIS  CLOSE_PARENTESIS  OPEN_PARENTESIS  MAIN  COLON  N_SENTENCIA:e CLOSE_BLOCK

;

N_FUNCTIONS::=
    N_FUNCTIONS N_FUNCTION:e1
    | 
    N_FUNCTION:e1

;

N_FUNCTION ::=
    N_PARAMETRO:e1
    ID:e2
    OPEN_PARENTESIS 
    FUNCTION 
    COLON 
    N_RETORNO_FUNCTION:e3
    N_SENTENCIA:n
    RETURN 
        N_VALOR_VARIABLE:vb
    PYC
    CLOSE_BLOCK 

    |
    N_PARAMETRO:e1
    ID:e2
    OPEN_PARENTESIS 
    FUNCTION 
    COLON 
    NULL:e3
    N_SENTENCIA:n
    CLOSE_BLOCK 

    |
    /*Funciones y procedimientos vacios*/
    N_PARAMETRO:e ID:id  OPEN_PARENTESIS  FUNCTION  COLON  NULL:nl CLOSE_BLOCK 

    |
    N_PARAMETRO:e1 ID:id OPEN_PARENTESIS  FUNCTION  COLON  N_RETORNO_FUNCTION:e3 RETURN N_VALOR_VARIABLE:vb  PYC CLOSE_BLOCK 

    
    //N_PARAMETRO:e1 ID:e2 OPEN_PARENTESIS  FUNCTION  COLON  N_RETORNO_FUNCTION:e3 N_SENTENCIA:n RETURN N_VALOR_VARIABLE:vb PYC CLOSE_BLOCK 
    |N_PARAMETRO:e1 ID:e2 OPEN_PARENTESIS  FUNCTION error:err{:
                String desc = "Falta \":\" depues de fun";
                String mes = parser.errorMessage(desc, parser.getS());
                //parser.report_(mes ,err);
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
        :}
    |N_PARAMETRO:e1 ID:e2 OPEN_PARENTESIS  FUNCTION COLON  N_RETORNO_FUNCTION:e3 N_SENTENCIA:n error:err CLOSE_BLOCK{:
                String desc = "Falta el return de la función";
                String mes = parser.errorMessage(desc, parser.getS());
                //parser.report_(mes ,err);
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
        :}
    |N_PARAMETRO:e1 ID:e2 OPEN_PARENTESIS  FUNCTION COLON  N_RETORNO_FUNCTION:e3 N_SENTENCIA:n RETURN N_VALOR_VARIABLE:vb PYC error:err {:
                String desc = "Falta el close block de la función";
                String mes = parser.errorMessage(desc, parser.getS());
                //parser.report_(mes ,err);
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
    :}
    |N_PARAMETRO:e1 ID:e2 OPEN_PARENTESIS  FUNCTION COLON  N_RETORNO_FUNCTION:e3 N_SENTENCIA:n RETURN N_VALOR_VARIABLE:vb error:err {:
                String desc = "Falta el PYC del retorno";
                String mes = parser.errorMessage(desc, parser.getS());
                //parser.report_(mes ,err);
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
    :}
    
    /*|
    error:e {: 
        String report = "Syntax error in line " + parser.getS().right + " Column " + parser.getS().left + ". No se esperaba este componente: " +parser.getS().value;
        //parser.addError(report + "\n");
        //parser.report_(report,e); 
        System.out.println("Error: " + "2\n\n\n\n\n\n");
        RESULT =  parser.createNodo("ERROR");
    :}*/
;
    
N_PARAMETRO ::=
    OPEN_PARENTESIS CLOSE_PARENTESIS
    |
    OPEN_PARENTESIS N_PARAMETRO_FUNCTION:e CLOSE_PARENTESIS
;
N_PARAMETRO_FUNCTION ::=
    N_RETORNO_FUNCTION:r ID:id COMA N_PARAMETRO_FUNCTION:n
    |
    N_RETORNO_FUNCTION:r ID:id
    |
    ID ID error:err{:
        String desc = "Debe ser un solo identificador. Si tiene varias palabras unasla: \"funcionMuesta o funcion_muestra\"   ";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
;
    
N_RETORNO_FUNCTION ::=
    INTENGER:n {:RESULT = parser.createNodo(n+"");:}|
    BOOLEAN:n {:RESULT = parser.createNodo(n+"");:}|
    CHAR:n {:RESULT = parser.createNodo(n+"");:}|
    ARRAY:n N_TIPOS_DECLARACION_MATRIZ:m {:RESULT = parser.createNodo(n+" "+m+"");:}|
    MATRIX:n N_TIPOS_DECLARACION_MATRIZ:m{:RESULT = parser.createNodo(n+" "+m+"");:}|
    error:err{:
    String desc = "En los parametros solo se aceptan los tipos: int, bln, chr, arr, mtx";
    String mes = parser.errorMessage(desc, parser.getS());
    DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
    RESULT = nodo;
    //parser.report_(mes ,err);
    :}
    ;

/* -------------------------CONTROL STAMENTS------------------------- */
N_SENTENCIA ::= 
    N_SENTENCIA:e N_WHILE:n
    |
    N_WHILE:n
    |
    N_SENTENCIA:e N_FOR:n
    |
    N_FOR:n
    |
    N_SENTENCIA:e N_IF:n
    |
    N_IF:n
    |
    N_SENTENCIA:e N_SWITCH:n 
    |
    N_SWITCH:n
    |
    N_SENTENCIA:e N_DECLARACION:n PYC 
    |
    N_DECLARACION:n PYC 
    |
    N_SENTENCIA:e N_PRINT:n
    |
    N_PRINT: n
    |
    N_SENTENCIA:e N_CIN:n
    |
    N_CIN:n
    |
    N_SENTENCIA:e N_CALL_FUNCTION:n PYC 
    |
    N_CALL_FUNCTION:n PYC 
    /*Errores*/
    /*|
    error:e {: 
        String report = "Syntax error in line " + parser.getS().right + " Column " + parser.getS().left + ". No se esperaba este componente: " +parser.getS().value;
        //parser.addError(report + "\n");
        //parser.report_(report,e); 
        ////System.out.println("Error: " + "3\n\n\n\n\n\n");
        RESULT =  parser.createNodo("ERROR");
    :}*/
;

N_WHILE ::= 
    //OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA CLOSE_PARENTESIS OPEN_PARENTESIS WHILE COLON N_SENTENCIA CLOSE_BLOCK
    OPEN_PARENTESIS:e1
    N_SENTENCIA_BOOLEANA_ANIDADA:e
    CLOSE_PARENTESIS:e3
    OPEN_PARENTESIS:e4
    WHILE:e5
    COLON:e6
    N_SENTENCIA:n
    CLOSE_BLOCK:e8
    |
    /*While vacio*/
    OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA:e2 CLOSE_PARENTESIS OPEN_PARENTESIS WHILE COLON CLOSE_BLOCK
    /*Errores en estructura del while*/
    |OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA error:err OPEN_PARENTESIS WHILE COLON N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta \")\" en la declaración del while"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA CLOSE_PARENTESIS error:err WHILE COLON N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta \"(\" en la declaración del while"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA CLOSE_PARENTESIS OPEN_PARENTESIS WHILE error:err N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta \":\" en la declaración del while"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

;

N_FOR ::= 
    OPEN_PARENTESIS 
    ID:id
    COMA 
    N_TO_FOR:n1
    TO 
    N_TO_FOR:n2
    COMA
    OP_SUM:o
    N_TO_FOR:n3
    CLOSE_PARENTESIS 
    OPEN_PARENTESIS 
    FOR 
    COLON 
    N_SENTENCIA:n
    CLOSE_BLOCK
    | 
    /*For vacio*/
    OPEN_PARENTESIS  ID:id  COMA  N_TO_FOR:n1  TO  N_TO_FOR:n2  COMA  OP_SUM:o N_TO_FOR:n3  CLOSE_PARENTESIS  OPEN_PARENTESIS  FOR  COLON  CLOSE_BLOCK
    
    
    /*Errores For*/
    |OPEN_PARENTESIS  error:err  COMA  N_TO_FOR:n1  TO  N_TO_FOR:n2  COMA  OP_SUM:o N_TO_FOR:n3  CLOSE_PARENTESIS  OPEN_PARENTESIS  FOR  COLON N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta el id del contadador en la declaración del while"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS  ID:id  error:err  N_TO_FOR:n1  TO  N_TO_FOR:n2  COMA  OP_SUM:o N_TO_FOR:n3  CLOSE_PARENTESIS  OPEN_PARENTESIS  FOR  COLON N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta \",\"  después del ID contador en la declaración del for"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS  ID:id  COMA  N_TO_FOR:n1  error:err  N_TO_FOR:n2  COMA  OP_SUM:o N_TO_FOR:n3  CLOSE_PARENTESIS  OPEN_PARENTESIS  FOR  COLON N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta \"-> o to\" en la declaración del for"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS  ID:id  COMA  N_TO_FOR:n1  TO  N_TO_FOR:n2  error:err  OP_SUM:o N_TO_FOR:n3  CLOSE_PARENTESIS  OPEN_PARENTESIS  FOR  COLON N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta \",\"  después del rango en la declaración del for"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS  ID:id  COMA  N_TO_FOR:n1  TO  N_TO_FOR:n2  COMA  error:err N_TO_FOR:n3  CLOSE_PARENTESIS  OPEN_PARENTESIS  FOR  COLON N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta \"+ o -\" en el incremento del for"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS  ID:id  COMA  N_TO_FOR:n1  TO  N_TO_FOR:n2  COMA  OP_SUM:o N_TO_FOR:n3  CLOSE_PARENTESIS  error:err  FOR  COLON N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta otro \"(\" en la declaración del for"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS  ID:id  COMA  N_TO_FOR:n1  TO  N_TO_FOR:n2  COMA  OP_SUM:o N_TO_FOR:n3  CLOSE_PARENTESIS  OPEN_PARENTESIS  FOR  error:err N_SENTENCIA CLOSE_BLOCK
    {: String desc = "Falta \":\" en la declaración del for"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |OPEN_PARENTESIS  ID:id  COMA  N_TO_FOR:n1  TO  N_TO_FOR:n2  COMA  OP_SUM:o N_TO_FOR:n3  CLOSE_PARENTESIS  OPEN_PARENTESIS  FOR  COLON N_SENTENCIA error:err
    {: String desc = "Falta \":)\" para cerrar el bloque for"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

;

N_TO_FOR::=
    NUMBER:n
        {:RESULT = n;:}
    | 
    
    ID:id
        {:RESULT = id;:}
    |
    error:err{:
        String desc = "Solo se admiten Numeros enteros y variables";
        String mes = parser.errorMessage(desc, parser.getS());
        //parser.report_(mes ,err);
        //DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = "ERROR";
    :}
        
;

N_IF ::= 
    OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA:bn CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON 
    N_SENTENCIA:n
    N_ELSE_IF:el
    CLOSE_BLOCK
    | /*If vacio*/
    OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA:bn CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON 
    N_ELSE_IF:el
    CLOSE_BLOCK

    |
    OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA:bn CLOSE_PARENTESIS error:err IF_SWITCH COLON N_SENTENCIA:n N_ELSE_IF CLOSE_BLOCK
    {: String desc = "Falta volver a abrir \"(\" en la declaración del if"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}

    |
    OPEN_PARENTESIS error CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON N_SENTENCIA:n N_ELSE_IF CLOSE_BLOCK
    {: 
        String desc = "No tiene sentencia boolena en la condición a evaluar"; 
        String mes = parser.errorMessage(desc, parser.getS()); 
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); 
        RESULT = nodo;:}
;

N_ELSE_IF ::=
    OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA:bn CLOSE_PARENTESIS COLON 
    N_SENTENCIA:n
    N_ELSE_IF:sw
    |
    /*Switch vacio*/
    OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA:bn CLOSE_PARENTESIS COLON 
    N_ELSE_IF:sw
    |
    OPEN_PARENTESIS ELSE CLOSE_PARENTESIS COLON 
    N_SENTENCIA:n
    |/*Else vacío*/
    OPEN_PARENTESIS ELSE CLOSE_PARENTESIS COLON 
    |
    |
    /*Manejo de errores*/
    OPEN_PARENTESIS error:err CLOSE_PARENTESIS COLON  N_SENTENCIA:n N_ELSE_IF:sw
    {: String desc = "No tiene sentencia boolena en la condición a evaluar"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
;

N_SWITCH ::=
    OPEN_PARENTESIS ID:id CLOSE_PARENTESIS OPEN_PARENTESIS 
    IF_SWITCH COLON 
    N_SWITCH_CASE:sw 
    CLOSE_BLOCK
    |
    OPEN_PARENTESIS error:err CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH COLON N_SWITCH_CASE:sw CLOSE_BLOCK
    {: String desc = "Falta la variable a comparar en la declaracion del switch"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
    |
    OPEN_PARENTESIS ID CLOSE_PARENTESIS error:err IF_SWITCH COLON N_SWITCH_CASE:sw CLOSE_BLOCK
    {: String desc = "Tiene que volver a abrir parentesis en la declaración del switch: (A=B)(if: ... :)"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
    |
    OPEN_PARENTESIS ID CLOSE_PARENTESIS OPEN_PARENTESIS IF_SWITCH error N_SWITCH_CASE:sw CLOSE_BLOCK
    {: String desc = "Falta \":\" en la declaración del switch"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
;

N_SWITCH_CASE ::=
    OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_SWITCH:bn CLOSE_PARENTESIS COLON 
    N_SENTENCIA:e
    N_SWITCH_CASE:sw
    |
    /*Switch vacio*/
    OPEN_PARENTESIS N_SENTENCIA_BOOLEANA_SWITCH:bn CLOSE_PARENTESIS COLON 
    N_SWITCH_CASE 
    |
    OPEN_PARENTESIS ELSE CLOSE_PARENTESIS COLON 
    N_SENTENCIA:e
    |/*Else vacío*/
    OPEN_PARENTESIS ELSE CLOSE_PARENTESIS COLON 
    /*Errores*/
    |
    OPEN_PARENTESIS error:err COLON
     N_SENTENCIA N_SWITCH_CASE:sw
            {:
                String desc = "Falta \":\" en la declaraciónd el switcch case";
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
                //parser.report_(mes ,err);
            :}
    | 
    OPEN_PARENTESIS error:err OPEN_PARENTESIS COLON N_SENTENCIA N_SWITCH_CASE:sw
    {: String desc = "Error en sentencia booleana del switch, debe ser de la forma: \"(OP_REL valorAComparar):\""; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
   
    
;

/* -------------------------VARIABLE DEFINITION------------------------------ */
N_CALL_FUNCTION::=
    ID:id OPEN_PARENTESIS N_CALL_FUNCTION_PARAMETROS:n CLOSE_PARENTESIS 
    |
    ID:id OPEN_PARENTESIS CLOSE_PARENTESIS
    |
    ID error:err OPEN_PARENTESIS{:
        String desc = "Falta el el identificador de la funcion";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        parser.report_error(mes ,err);
    :}
    |
    ID OPEN_PARENTESIS error:err{:
        String desc = "Falta cerrar parentesis en llamado de función";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        parser.report_error(mes ,err);
    :}
;

N_CALL_FUNCTION_PARAMETROS::=
    N_VALOR_VARIABLE:e1 COMA N_CALL_FUNCTION_PARAMETROS:e 
    |
    
    N_VALOR_VARIABLE:e
    |
    N_VALOR_VARIABLE:e1 COMA error:err{:
        String desc = "Coma de más o falta valor en parametros de funcion";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
;
N_SENTENCIA_BOOLEANA_ANIDADA ::=
    N_SENTENCIA_BOOLEANA:e1
    N_AND_OR:e2
    |
    N_SENTENCIA_BOOLEANA:bl
    |
    OPEN_PARENTESIS
    N_SENTENCIA_BOOLEANA_ANIDADA:bl
    CLOSE_PARENTESIS
    N_AND_OR:nd
    |
    OPEN_PARENTESIS
    N_SENTENCIA_BOOLEANA_ANIDADA:bl
    CLOSE_PARENTESIS
    |

    /*Agregados por AST*/
    OPEN_PARENTESIS CLOSE_PARENTESIS error:err{:
            String desc = "Parentesis vacios en sentencia booleana";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            parser.report_error(mes ,err);
    :}
    |
    error:err OPEN_PARENTESIS CLOSE_PARENTESIS{:
            String desc = "Parentesis vacios en sentencia booleana";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            parser.report_error(mes ,err);
    :}

    /* NO ESTA EN EL AST
    OPEN_PARENTESIS error:err CLOSE_PARENTESIS N_SENTENCIA_BOOLEANA_ANIDADA{:
            String desc = "Error en sentecia boolenada entre parentesis. Parentesis vacios en sentencia booleana";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
    :}*/

;

N_AND_OR::=
    CON_AND:nd
    N_SENTENCIA_BOOLEANA_ANIDADA:bl
    |
    CON_OR:nd
    N_SENTENCIA_BOOLEANA_ANIDADA:bl
    |
    CON_AND error:err
    {: String desc = "Error en sentencia booleana para comparar con AND."; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
    |
    CON_OR error:err
    {: String desc = "Error en sentencia booleana para comparar con OR"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}


;

N_SENTENCIA_BOOLEANA ::= 
    ID:id OP_REL:op EXPR_LIST:n 
    |
    /* AL REVES */
    NUMBER:n OP_REL:op ID:id  
    |
    STRING:s OP_REL:op ID:id
    |
    STRING OP_REL error:err {:
            String desc = "Operando derecho con String no valido";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
        :}
    |
    FALSE:f OP_REL:op ID:id  
    |
    FALSE OP_REL error:err {:
            String desc = "Operando derecho con false no válido";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
        :}
    |
    TRUE:t OP_REL:op ID:id  
    |
    TRUE OP_REL error:err {:
            String desc = "Operando derecho con true no válido";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
        :}
    |
    /*Number*/
    NUMBER:n1 OP_REL:op NUMBER:n2 
    |
    NUMBER OP_REL error:err {:
            String desc = "Operando derecho con número no válido";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
        :}
    |
    NUMBER:n OP_REL:op STRING:s 
    |
    NUMBER:n OP_REL:op FALSE:f 
    |
    NUMBER:n OP_REL:op TRUE:t 
    |
    /* AL REVES */
    STRING:s OP_REL:op NUMBER:n 
    |
    FALSE:f OP_REL:op NUMBER:n 
    |
    TRUE:t OP_REL:op NUMBER:n  
    |
    /*STRING*/
    STRING:s1 OP_REL:op STRING:s2
    |
    STRING:s OP_REL:op FALSE:f 
    |
    STRING:s OP_REL:op TRUE:t
    |
    /* AL REVES */
    FALSE:f OP_REL:op STRING:s 
    |
    TRUE:t OP_REL:op STRING:s
    |
    /*TRUE - FALSE*/
    TRUE:t OP_REL:op FALSE:f 
    |
    TRUE:t1 OP_REL:op TRUE:t2 
    |
    FALSE:f1 OP_REL:op FALSE:f2 
    |
    FALSE:f OP_REL:op TRUE:t
    |
    error:err OP_REL {:
            String desc = "Error en sentencia booleana por izquierda";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
        :}
    |
    OP_REL error:err {:
            String desc = "Error en sentencia booleana por derecha";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
        :}
;

N_SENTENCIA_BOOLEANA_SWITCH::=
    ID:id OP_REL:op
    |
    OP_REL:op ID:id
    |
    STRING:s OP_REL:op 
    |
    OP_REL:op STRING:s 
    |
    OP_REL:op NUMBER:n 
    |
    OP_REL:op FALSE:f 
    |
    OP_REL:op TRUE:t 
    |
    NUMBER:n OP_REL:op 
    |
    NUMBER:n1 BETWEEN:b NUMBER:n2
    |
    ID:id1 BETWEEN:b ID:id2 
    |
    ID:id1 BETWEEN:b NUMBER:id2 
    |
    NUMBER:id1 BETWEEN:b ID:id2 
    |
    TRUE:t 
    | 
    FALSE:f 
    |
    CHAR_ELEMENT:f
    |
    NUMBER:f
    |
    error:err{:
        String desc = "Error en sentencia booleana del switch: falta identificador u operador relacional";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
;

N_DECLARACION ::= 
    ID:id COLON N_SENTENCIA_BOOLEANA_ANIDADA:bn 
    |
    ID:id COLON EXPR_LIST:ex
    |
    //TIPO id,id,id
    INTENGER:i N_DECLARACION_ID:n
    |
    BOOLEAN:i N_DECLARACION_ID:de
    |
    CHAR:i N_DECLARACION_ID:de
    |
    //int id: 2+3+5/2*4...
    INTENGER:i ID:id COLON EXPR_LIST:ex
    |
    //bln id: ((4=7)and("hola"=id))
    N_BOOLEAN_ID:id N_BOOLEAN_VALUE:va 
    |
    //chr id: 'a'
    CHAR:i ID:id COLON CHAR_ELEMENT:ch
    |    
    /*Arreglos*/
    ID:id
    OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
    COLON
    EXPR_LIST:ex
    |
    ID:id
    error:err N_TO_FOR:n1 CLOSE_SQR_BRACKET
    COLON
    EXPR_LIST:ex{: String desc = "Fala \"[\" en la declaración del arreglo"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
    |
    ID:id
    OPEN_SQR_BRACKET N_TO_FOR:n1 error:err
    COLON
    EXPR_LIST:ex{: String desc = "Fala \"]\" en la declaración del arreglo"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
    |
    ID:id
    OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
    error:err
    EXPR_LIST:ex{: String desc = "Fala \"]\" en la declaración del arreglo"; String mes = parser.errorMessage(desc, parser.getS()); DefaultMutableTreeNode nodo = parser.createNodo("ERROR"); RESULT = nodo;:}
    |
    ID:id
    OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
    COLON
    N_SENTENCIA_BOOLEANA_ANIDADA:ex
    |
    /*Agregado por AST*/
    ID:id
    OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
    COLON
    N_CALL_FUNCTION:ex
    |
    //solo declaracion variable: arr [1] Int id
    ARRAY :i
    OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
    N_TIPOS_DECLARACION_MATRIZ:t
    ID:id
    |
    //Con valor de una vez: arr Int id: [1,2,3,4...]
    ARRAY:i
    N_TIPOS_DECLARACION_MATRIZ:t
    ID:id COLON 
    OPEN_SQR_BRACKET
    N_ARREGLO:ar
    |
    /*Matriz*/
    ID:id
    OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
    OPEN_SQR_BRACKET N_TO_FOR:n2 CLOSE_SQR_BRACKET
    COLON
    EXPR_LIST:ex
    |
    ID:id
    OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
    OPEN_SQR_BRACKET N_TO_FOR:n2 CLOSE_SQR_BRACKET
    COLON
    N_SENTENCIA_BOOLEANA_ANIDADA:ex
    |
    //solo declaracion variable: mtx [1][1] TIPO matriz
    MATRIX:i
    OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
    OPEN_SQR_BRACKET N_TO_FOR:n2 CLOSE_SQR_BRACKET
    N_TIPOS_DECLARACION_MATRIZ:t
    ID:id
    |
    //Con valor de una vez: mtx TIPO matriz:[...[A],[a],[B],b...]
    MATRIX:i
    N_TIPOS_DECLARACION_MATRIZ:t
    ID:id COLON 
    OPEN_SQR_BRACKET
    N_MATRIZ:m  
    CLOSE_SQR_BRACKET
    |
    /*FUNCIONES*/
    //id:funcion(p1,p2,p3)
    ID:e1 COLON N_CALL_FUNCTION:e2
    |
    //int id: funcion(p1,p2,p3...)
    INTENGER:e1 ID:e2 COLON N_CALL_FUNCTION:e3
    |
    INTENGER COLON error:err{:
        String desc = "Fala identificador del int";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    INTENGER ID error:err{:
        String desc = "Falta \":\" en la asignación del int";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    //mtx TIPO id: funcion(p1,p2,p3...)
    MATRIX:i N_TIPOS_DECLARACION_MATRIZ:t ID:id COLON N_CALL_FUNCTION:f 
    
    |
    MATRIX N_TIPOS_DECLARACION_MATRIZ ID error:err N_CALL_FUNCTION:f{:
        String desc = "Falta \":\" en la asignación de la matriz";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
      |
    MATRIX N_TIPOS_DECLARACION_MATRIZ error:err COLON N_CALL_FUNCTION{:
        String desc = "Falta id de la matriz";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    //arr TIPO id: funcion(p1,p2,p3...)
    ARRAY:a N_TIPOS_DECLARACION_MATRIZ:t ID:id COLON N_CALL_FUNCTION:f 
    |
    ARRAY COLON error:err{:
        String desc = "Fala tipo del array";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    ARRAY N_TIPOS_DECLARACION_MATRIZ error:err{:
        String desc = "Falta \":\" en la asignación del array";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
      |
    ARRAY N_TIPOS_DECLARACION_MATRIZ COLON error:err{:
        String desc = "Falta id del array";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    //char id: funcion(p1,p2,p3...)
    CHAR:c ID:i COLON N_CALL_FUNCTION:f 
    |
    CHAR COLON error:err{:
        String desc = "Fala identificador del char";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    CHAR ID error:err{:
        String desc = "Falta \":\" en la asignación del char";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
;

N_DECLARACION_ID::=
    ID:id COMA N_DECLARACION_ID:ids
    | 
    ID:id
    |
    ID ID
    error:err{:
        String desc = "los ids deben ir separados por comas";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
;

N_VALOR_VARIABLE ::=
    NUMBER:e1 {: RESULT = (parser.createNodo(e1+"")); :}
    | 
    ID:e1 {: RESULT = (parser.createNodo(e1+"")); :}
    | 
    STRING:e1 {: RESULT = (parser.createNodo(e1+"")); :}
    |
    NULL:e1  {: RESULT = (parser.createNodo(e1+"")); :}
    |
    CHAR_ELEMENT:e1 {: RESULT = (parser.createNodo(e1+"")); :}
    |
    TRUE:e1    {: RESULT = (parser.createNodo(e1+"")); :}
    |
    FALSE:e1   {: RESULT = (parser.createNodo(e1+"")); :}
    |
    
;

N_TIPOS_DECLARACION_MATRIZ ::=
    INTENGER:e {: RESULT = (parser.createNodo(e+"")); :}
    |
    BOOLEAN:e {: RESULT = (parser.createNodo(e+"")); :}
    |
    CHAR:e {: RESULT = (parser.createNodo(e+"")); :}
    |
    error:err{:
        String desc = "Solo se permiten Int, boolean y char, id en los arreglos. Usar otro tipo o no especificar el no es válido";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}

;

//solo matrices de dos dimensiones
N_MATRIZ ::=  
    OPEN_SQR_BRACKET N_ARREGLO:n
    |
    OPEN_SQR_BRACKET N_ARREGLO:a COMA N_MATRIZ:n 
    |
    N_VALOR_VARIABLE:a COMA N_MATRIZ:n 
    | 
    N_VALOR_VARIABLE:n
    |
    error:err{:
        String desc = "Solo se permiten arreglos de dos dimensiones";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
        :}
;
N_ARREGLO ::=
    N_VALOR_VARIABLE:a COMA N_ARREGLO:n 
    | 
    N_VALOR_VARIABLE:a CLOSE_SQR_BRACKET
    |
    N_VALOR_VARIABLE error:err{:
        RESULT = parser.createNodo("ERROR");
        String desc = "Estructura del arreglo incompleta";
        String mes = parser.errorMessage(desc, parser.getS());
        //DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = "ERROR";
        //parser.report_(mes ,err);
      :}
    
;

N_BOOLEAN_ID ::=
    BOOLEAN:bl ID:id COLON 
    |
    BOOLEAN error:err COLON{:
        String desc = "Falta el identificador del boolean en la declaracion";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    BOOLEAN ID error:err{:
        String desc = "Falta \":\" en la declacion booleana";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
;

N_BOOLEAN_VALUE::=
    FALSE:n
    | 
    TRUE:n
    | 
    N_SENTENCIA_BOOLEANA_ANIDADA:e 
    | 
    
    /*NO ESTA EN EL Arbolito - eliminado
    ID:id OPEN_PARENTESIS N_ARGUMENTOS:ar CLOSE_PARENTESIS 
    | 
    ID:id OPEN_PARENTESIS CLOSE_PARENTESIS
    |*/
    
    N_CALL_FUNCTION:ar
    
    |
        error:err{:
        String desc = "Error en la definición del booleno, tipo no compatible con Boolean o falta PYC";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
        :}
;

N_ARGUMENTOS ::=
    ID:id COMA N_ARGUMENTOS:ar
    | 
    ID:id PYC
    |
       ID error:err {:
        String desc = "Falta PYC";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
        :}
    |
        ID ID error:err {:
            String desc = "Los ids deben ir separados por coma";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
        :}
    /*| NO ESTA EN EL Arbolito - eliminado
        ID COLON error:err{:
            String desc = "No se pueden hacer declaraciones";
            String mes = parser.errorMessage(desc, parser.getS());
            DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
            RESULT = nodo;
            //parser.report_(mes ,err);
        :}
    */
;
/* -----------------------------OPERATORS--------------------------------- */
N_PRINT ::=
    OPEN_PARENTESIS PRINT error:err {:
        String desc = "Faltan los \":\" en el print";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
        :}
    |
    OPEN_PARENTESIS PRINT  COLON  STRING:e N_PRINT_IMPRESS:n CLOSE_BLOCK error:err {:
        String desc = "Falta PYC en el print";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
        :}

    |
    OPEN_PARENTESIS PRINT  COLON   N_TO_FOR  N_PRINT_IMPRESS:n CLOSE_BLOCK error:err {:
        String desc = "Falta PYC en el print";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
        :}
    |

    OPEN_PARENTESIS
    PRINT 
    COLON 
    STRING:e
    N_PRINT_IMPRESS:n
    CLOSE_BLOCK 
    PYC
    |
    OPEN_PARENTESIS
    PRINT 
    COLON 
    N_TO_FOR:e
    N_PRINT_IMPRESS:n
    CLOSE_BLOCK 
    PYC
    |
    OPEN_PARENTESIS
    PRINT 
    COLON 
    NEW_LINE:e
    N_PRINT_IMPRESS:n
    CLOSE_BLOCK 
    PYC
    | /*Print vacio*/
    OPEN_PARENTESIS PRINT COLON CLOSE_BLOCK  PYC
;

N_PRINT_IMPRESS::=
    N_PRINT_IMPRESS:e1 OP_SUM N_VALOR_VARIABLE:n
    |
    OP_SUM N_VALOR_VARIABLE:n
    |
    N_PRINT_IMPRESS:e1 OP_SUM NEW_LINE:nl
    |
    OP_SUM:n NEW_LINE:nl
    |
    OP_SUM error:err{:
        String desc = "Falta cierre de PRINT o hay declaraciones no aceptadas\nDatos aceptados: String, chars, variables, números, saltos de linea (ln)";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;        
        //parser.report_(mes ,err);
    :}
    | 
            OP_SUM ID:id
            OPEN_SQR_BRACKET N_TO_FOR:n CLOSE_SQR_BRACKET
            |
            OP_SUM ID:id
            OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
            OPEN_SQR_BRACKET N_TO_FOR:n2 CLOSE_SQR_BRACKET

    |
;

N_CIN ::=
    OPEN_PARENTESIS 
    CIN
    COLON 
    ID:id
    CLOSE_BLOCK 
    PYC 
    |
    OPEN_PARENTESIS CIN
    error:err{:
        String desc = "Falta \":\" en el CIN";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    OPEN_PARENTESIS CIN COLON
    error:err{:
        String desc = "Falta varibale en el CIN";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    |
    OPEN_PARENTESIS CIN COLON ID
    error:err {:
        String desc = "Valores de más. CIN solo llama a una variable o falta :)";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
        
    :}
    |
    OPEN_PARENTESIS CIN COLON ID CLOSE_BLOCK error:err {:
        String desc = "Falta PYC";
        String mes = parser.errorMessage(desc, parser.getS());
        DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
        RESULT = nodo;
        //parser.report_(mes ,err);
    :}
    
;

/* ------------------------------MATHEMATICS--------------------------------- */

EXPR_LIST   ::= EXPR_LIST:e1 EXPR:e2 
            |OPEN_PARENTESIS EXPR_LIST:e1 CLOSE_PARENTESIS EXPR_LIST:e2
            | EXPR:e                          
;

EXPR        ::= OP_SUM  EXPR:e2 
            | EXPR:e1 OP_MULTI_DIV EXPR:e2
            | OPEN_PARENTESIS EXPR_LIST:e CLOSE_PARENTESIS
            | EXPR:e1 MOD EXPR:e2
            | NUMBER:n
            | STRING:s
            | TRUE:b
            | FALSE:b
            | CHAR_ELEMENT:c
            | NULL:nl                        
            | ID:nl
            | 
            ID:id
            OPEN_SQR_BRACKET N_TO_FOR:n CLOSE_SQR_BRACKET
            |
            ID:id
            OPEN_SQR_BRACKET N_TO_FOR:n1 CLOSE_SQR_BRACKET
            OPEN_SQR_BRACKET N_TO_FOR:n2 CLOSE_SQR_BRACKET
            |
            OP_SUM:su error:err{:
                String desc = "";
                desc = "Elemento para sumar/restar en la expresión no válida";
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
                //parser.report_(mes ,err);
            :}
            |
            OP_MULTI_DIV:md error:err{:
                String  desc = "Elemento para multiplicar/división en la expresión no válida";
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
                //parser.report_(mes ,err);
            :}
            |
            MOD error:err{:
                String  desc = "Elemento para sacar mod no es válido";
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
                //parser.report_(mes ,err);
            :}
            /*| 
            ID:id
            OPEN_SQR_BRACKET error:err CLOSE_SQR_BRACKET {:
                String  desc = "Valor no valida para corchetes arreglo";
                String mes = parser.errorMessage(desc, parser.getS());
                DefaultMutableTreeNode nodo = parser.createNodo("ERROR");
                RESULT = nodo;
                //parser.report_(mes ,err);
            :}*/
;

